"""
Parent–School Dashboard — Dual-mode server (FastAPI with fallback WSGI)

This file addresses environments that may lack the builtin `ssl` module (which causes FastAPI/Starlette/anyio imports to fail).

Behavior:
- If the runtime has the `ssl` module *and* FastAPI is importable, the file constructs a FastAPI app (same endpoints as the original design).
- If `ssl` is missing or FastAPI cannot be imported, the file falls back to a lightweight WSGI server implemented using only Python standard library modules (no external dependencies).

Why this change?
- The original traceback showed `ModuleNotFoundError: No module named 'ssl'` when FastAPI (via Starlette/anyio) attempted to import `ssl`. Importing FastAPI at module import time therefore caused the crash. By detecting `ssl` presence and deferring/guarding FastAPI imports we avoid that crash and provide a functional fallback.

How to run:
- Preferred (FastAPI): make sure your Python build includes the `ssl` module and FastAPI is installed. Then run with uvicorn:
    uvicorn main:app --reload

- Fallback (no `ssl` or FastAPI): just run this file directly and it will start an HTTP server on port 8000:
    python main.py

- Run the included unit tests (they run against the data-layer, not the HTTP layer):
    python main.py --test

Endpoints supported (both modes):
- GET  /api/parent/{parent_id}/feed
- GET  /api/student/{student_id}/summary
- POST /api/messages              (JSON body)
- POST /api/consent               (JSON body)
- POST /api/chatbot/query         (JSON body)
- POST /admin/seed                (seed demo data)

This file aims to be self-contained and friendly for sandboxed environments without SSL.
"""

from __future__ import annotations
import sys
import json
import sqlite3
from datetime import datetime, date
from typing import List, Optional, Dict, Any, Tuple
import importlib

# ---------------------------
# Helper: safe import
# ---------------------------

def safe_import(name: str):
    try:
        return importlib.import_module(name)
    except Exception:
        return None

# Check for ssl availability
ssl_mod = safe_import("ssl")
fastapi_mod = None
uvicorn_mod = None

if ssl_mod is not None:
    # try importing FastAPI only if ssl is present
    fastapi_mod = safe_import("fastapi")
    uvicorn_mod = safe_import("uvicorn")

# ---------------------------
# Data layer (sqlite3-backed)
# ---------------------------
class DataStore:
    """Simple sqlite3-backed data store with the tables needed by the API.
    Uses a file-based DB by default (parent_school.db) and supports :memory: for tests.
    """

    def __init__(self, db_path: str = "./parent_school.db"):
        self.db_path = db_path
        self._conn = sqlite3.connect(self.db_path, check_same_thread=False)
        # Return rows as dicts
        self._conn.row_factory = sqlite3.Row
        self.init_db()

    def init_db(self):
        cur = self._conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS students (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                dob TEXT,
                class_name TEXT,
                roll_no TEXT,
                photo_url TEXT,
                emergency_contact TEXT
            )
            """
        )
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS attendance (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                student_id INTEGER,
                date TEXT NOT NULL,
                status TEXT NOT NULL,
                reason TEXT,
                recorded_by TEXT
            )
            """
        )
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS grades (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                student_id INTEGER,
                subject TEXT NOT NULL,
                term TEXT NOT NULL,
                score INTEGER NOT NULL,
                max_score INTEGER DEFAULT 100,
                remarks TEXT
            )
            """
        )
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                from_user_id INTEGER NOT NULL,
                to_user_id INTEGER NOT NULL,
                student_id INTEGER,
                body TEXT NOT NULL,
                attachments TEXT,
                read_at TEXT,
                created_at TEXT
            )
            """
        )
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS consent (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                parent_id INTEGER NOT NULL,
                student_id INTEGER NOT NULL,
                data_category TEXT NOT NULL,
                allowed INTEGER DEFAULT 0,
                timestamp TEXT
            )
            """
        )
        self._conn.commit()

    # -----------------
    # CRUD & queries
    # -----------------
    def seed_demo(self) -> bool:
        cur = self._conn.cursor()
        # check already seeded (simple check)
        cur.execute("SELECT COUNT(*) as c FROM students")
        if cur.fetchone()[0] > 0:
            return False
        # seed a student
        cur.execute(
            "INSERT INTO students (name, dob, class_name, roll_no, photo_url, emergency_contact) VALUES (?,?,?,?,?,?)",
            ("Aisha Sharma", "2013-05-17", "6A", "12", NULL_PLACEHOLDER(), "+91-98765xxxx"),
        )
        student_id = cur.lastrowid
        # attendance
        cur.executemany(
            "INSERT INTO attendance (student_id, date, status, reason) VALUES (?,?,?,?)",
            [
                (student_id, "2025-09-01", "present", None),
                (student_id, "2025-09-02", "absent", "fever"),
                (student_id, "2025-09-03", "present", None),
            ],
        )
        # grades
        cur.executemany(
            "INSERT INTO grades (student_id, subject, term, score, max_score, remarks) VALUES (?,?,?,?,?,?)",
            [
                (student_id, "Math", "Term1", 82, 100, "Good"),
                (student_id, "Science", "Term1", 78, 100, "Needs practice"),
            ],
        )
        self._conn.commit()
        return True

    def get_parent_feed(self, parent_id: int) -> List[Dict[str, Any]]:
        # A simple static feed + a personal card placeholder
        now = datetime.utcnow().isoformat()
        feed = [
            {"type": "announcement", "title": "Sports Day on 2025-10-15", "body": "All students to wear white.", "date": now},
            {"type": "personal", "title": "Pending fee", "body": "Tuition fee for October is pending.", "date": now},
        ]
        return feed

    def get_student_summary(self, student_id: int) -> Dict[str, Any]:
        cur = self._conn.cursor()
        cur.execute("SELECT * FROM students WHERE id = ?", (student_id,))
        s = cur.fetchone()
        if s is None:
            raise KeyError("Student not found")
        # attendance percent
        cur.execute("SELECT status FROM attendance WHERE student_id = ?", (student_id,))
        rows = cur.fetchall()
        if rows:
            present = sum(1 for r in rows if r[0].lower() == "present")
            attendance_percent = round((present / len(rows)) * 100, 2)
        else:
            attendance_percent = 0.0
        # recent grades
        cur.execute("SELECT subject, term, score, max_score, remarks FROM grades WHERE student_id = ? ORDER BY id DESC LIMIT 5", (student_id,))
        grades = [dict(subject=r[0], term=r[1], score=r[2], max_score=r[3], remarks=r[4]) for r in cur.fetchall()]
        return {
            "id": s["id"],
            "name": s["name"],
            "class_name": s["class_name"],
            "roll_no": s["roll_no"],
            "attendance_percent": attendance_percent,
            "recent_grades": grades,
        }

    def create_message(self, payload: Dict[str, Any]) -> int:
        cur = self._conn.cursor()
        attachments = ",".join(payload.get("attachments") or []) if payload.get("attachments") else None
        created_at = datetime.utcnow().isoformat()
        cur.execute(
            "INSERT INTO messages (from_user_id, to_user_id, student_id, body, attachments, created_at) VALUES (?,?,?,?,?,?)",
            (payload["from_user_id"], payload["to_user_id"], payload.get("student_id"), payload["body"], attachments, created_at),
        )
        self._conn.commit()
        return cur.lastrowid

    def set_consent(self, payload: Dict[str, Any]) -> int:
        cur = self._conn.cursor()
        timestamp = datetime.utcnow().isoformat()
        cur.execute(
            "INSERT INTO consent (parent_id, student_id, data_category, allowed, timestamp) VALUES (?,?,?,?,?)",
            (payload["parent_id"], payload["student_id"], payload["data_category"], 1 if payload["allowed"] else 0, timestamp),
        )
        self._conn.commit()
        return cur.lastrowid

    def chatbot_query(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        parent_id = payload.get("parent_id")
        student_id = payload.get("student_id")
        consent_scope = payload.get("consent_scope") or []
        # Basic consent check: if consent_scope provided, ensure at least one matching allowed consent exists
        if student_id and consent_scope:
            cur = self._conn.cursor()
            cur.execute(
                "SELECT data_category FROM consent WHERE parent_id = ? AND student_id = ? AND allowed = 1",
                (parent_id, student_id),
            )
            allowed = {r[0] for r in cur.fetchall()}
            if not any(cat in allowed for cat in consent_scope):
                return {"answer": "No consent to access requested data categories. Please update consent settings.", "sources": []}
        snippets = []
        if student_id:
            cur = self._conn.cursor()
            cur.execute("SELECT date, status, reason FROM attendance WHERE student_id = ? ORDER BY date DESC LIMIT 5", (student_id,))
            for r in cur.fetchall():
                snippets.append(f"{r[0]}: {r[1]} ({r[2] or 'no reason'})")
            cur.execute("SELECT term, subject, score, max_score, remarks FROM grades WHERE student_id = ? ORDER BY id DESC LIMIT 5", (student_id,))
            for r in cur.fetchall():
                snippets.append(f"{r[0]} - {r[1]}: {r[2]}/{r[3]} ({r[4] or ''})")
        answer = f"(Placeholder) I found {len(snippets)} records related to your query. Here are brief snippets:\n" + "\n".join(snippets[:5])
        return {"answer": answer, "sources": snippets}

# small helper because sqlite doesn't like None for a text column insertion if we want 'NULL'
def NULL_PLACEHOLDER():
    return None

# ---------------------------
# Build FastAPI app (only if ssl present and FastAPI import worked)
# ---------------------------
app = None

if ssl_mod is not None and fastapi_mod is not None:
    # Import things from FastAPI lazily
    from fastapi import FastAPI, HTTPException, Depends
    from fastapi.middleware.cors import CORSMiddleware
    from pydantic import BaseModel
    from typing import List
    from sqlalchemy import create_engine  # only to signal optional advanced replacement (not used)

    # Pydantic schemas (subset for request validation)
    class MessageCreateSchema(BaseModel):
        from_user_id: int
        to_user_id: int
        student_id: Optional[int] = None
        body: str
        attachments: Optional[List[str]] = None

    class ConsentCreateSchema(BaseModel):
        parent_id: int
        student_id: int
        data_category: str
        allowed: bool

    class ChatQuerySchema(BaseModel):
        parent_id: int
        student_id: Optional[int] = None
        query: str
        consent_scope: Optional[List[str]] = None

    # create app and datastore
    app = FastAPI(title="Parent-School Dashboard API (MVP)")
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    store = DataStore()

    # dependency
    def get_store():
        return store

    @app.get("/api/parent/{parent_id}/feed")
    def get_parent_feed(parent_id: int, store: DataStore = Depends(get_store)):
        return store.get_parent_feed(parent_id)

    @app.get("/api/student/{student_id}/summary")
    def get_student_summary(student_id: int, store: DataStore = Depends(get_store)):
        try:
            return store.get_student_summary(student_id)
        except KeyError:
            raise HTTPException(status_code=404, detail="Student not found")

    @app.post("/api/messages")
    def create_message(msg: MessageCreateSchema, store: DataStore = Depends(get_store)):
        mid = store.create_message(msg.dict())
        return {"ok": True, "message_id": mid}

    @app.post("/api/consent")
    def set_consent(payload: ConsentCreateSchema, store: DataStore = Depends(get_store)):
        cid = store.set_consent(payload.dict())
        return {"ok": True, "consent_id": cid}

    @app.post("/api/chatbot/query")
    def chatbot_query(q: ChatQuerySchema, store: DataStore = Depends(get_store)):
        return store.chatbot_query(q.dict())

    @app.post("/admin/seed")
    def seed_demo(store: DataStore = Depends(get_store)):
        ok = store.seed_demo()
        return {"ok": ok}

# ---------------------------
# Fallback WSGI app (no FastAPI required)
# ---------------------------
else:
    # We'll implement a minimal WSGI app with the same endpoints and semantics.
    from wsgiref.simple_server import make_server
    from urllib.parse import parse_qs, urlparse

    store = DataStore()

    def _json_response(start_response, obj, status='200 OK'):
        body = json.dumps(obj, default=str).encode('utf-8')
        headers = [('Content-Type', 'application/json'), ('Content-Length', str(len(body)))]
        start_response(status, headers)
        return [body]

    def _read_json_body(environ):
        try:
            length = int(environ.get('CONTENT_LENGTH', '0') or '0')
        except Exception:
            length = 0
        if length:
            data = environ['wsgi.input'].read(length)
            try:
                return json.loads(data.decode('utf-8'))
            except Exception:
                return None
        # maybe chunked or empty
        return None

    def wsgi_app(environ, start_response):
        method = environ.get('REQUEST_METHOD', 'GET').upper()
        path = environ.get('PATH_INFO', '')

        # Routing
        try:
            if method == 'GET' and path.startswith('/api/parent/') and path.endswith('/feed'):
                # /api/parent/{parent_id}/feed
                parts = path.strip('/').split('/')
                parent_id = int(parts[2])
                data = store.get_parent_feed(parent_id)
                return _json_response(start_response, data)

            if method == 'GET' and path.startswith('/api/student/') and path.endswith('/summary'):
                parts = path.strip('/').split('/')
                student_id = int(parts[1])
                try:
                    data = store.get_student_summary(student_id)
                    return _json_response(start_response, data)
                except KeyError:
                    return _json_response(start_response, {"detail": "Student not found"}, status='404 Not Found')

            if method == 'POST' and path == '/api/messages':
                payload = _read_json_body(environ) or {}
                if not payload:
                    return _json_response(start_response, {"detail": "Invalid or missing JSON body"}, status='400 Bad Request')
                mid = store.create_message(payload)
                return _json_response(start_response, {"ok": True, "message_id": mid})

            if method == 'POST' and path == '/api/consent':
                payload = _read_json_body(environ) or {}
                if not payload:
                    return _json_response(start_response, {"detail": "Invalid or missing JSON body"}, status='400 Bad Request')
                cid = store.set_consent(payload)
                return _json_response(start_response, {"ok": True, "consent_id": cid})

            if method == 'POST' and path == '/api/chatbot/query':
                payload = _read_json_body(environ) or {}
                if not payload:
                    return _json_response(start_response, {"detail": "Invalid or missing JSON body"}, status='400 Bad Request')
                ans = store.chatbot_query(payload)
                return _json_response(start_response, ans)

            if method == 'POST' and path == '/admin/seed':
                ok = store.seed_demo()
                return _json_response(start_response, {"ok": ok})

            # default
            return _json_response(start_response, {"detail": "Not found"}, status='404 Not Found')
        except Exception as e:
            # Avoid leaking internal trace in production; here we return the error for developer convenience.
            return _json_response(start_response, {"detail": "Internal server error", "error": str(e)}, status='500 Internal Server Error')

# ---------------------------
# Unit tests for the data layer
# ---------------------------
def run_unit_tests():
    print("Running unit tests against DataStore (in-memory)...")
    ds = DataStore(db_path=":memory:")
    # ensure empty
    try:
        try_seed = ds.seed_demo()
        assert try_seed is True, "Seed should return True on fresh DB"
        # calling seed again should return False
        assert ds.seed_demo() is False, "Re-seeding should return False"

        # fetch the seeded student id
        cur = ds._conn.cursor()
        cur.execute("SELECT id FROM students LIMIT 1")
        student_id = cur.fetchone()[0]

        summary = ds.get_student_summary(student_id)
        assert summary['name'].startswith('Aisha'), "Student name should be seeded"
        assert isinstance(summary['attendance_percent'], float), "attendance_percent should be a float"

        # create message
        mid = ds.create_message({
            'from_user_id': 1,
            'to_user_id': 2,
            'student_id': student_id,
            'body': 'Hello teacher',
            'attachments': []
        })
        assert isinstance(mid, int) and mid > 0

        # consent
        cid = ds.set_consent({'parent_id': 1, 'student_id': student_id, 'data_category': 'grades', 'allowed': True})
        assert isinstance(cid, int) and cid > 0

        # chatbot with consent scope that exists
        resp = ds.chatbot_query({'parent_id': 1, 'student_id': student_id, 'query': 'How is math?', 'consent_scope': ['grades']})
        assert 'answer' in resp

        # chatbot with disallowed scope
        resp2 = ds.chatbot_query({'parent_id': 99, 'student_id': student_id, 'query': 'How is math?', 'consent_scope': ['grades']})
        # parent_id 99 has no consent, so we expect a permission message
        assert 'No consent' in resp2['answer']

        print("All unit tests passed.")
    except AssertionError as e:
        print("Unit test failure:", e)
        raise

# ---------------------------
# Entrypoint
# ---------------------------
if __name__ == '__main__':
    if '--test' in sys.argv:
        run_unit_tests()
        sys.exit(0)

    if app is not None:
        # FastAPI mode: run uvicorn if available, else instruct the user to run uvicorn.
        if uvicorn_mod is not None:
            print("Starting FastAPI app with uvicorn on http://0.0.0.0:8000")
            uvicorn_mod.run("main:app", host="0.0.0.0", port=8000, reload=True)
        else:
            print("FastAPI is available but uvicorn wasn't found. Start the app with: uvicorn main:app --reload")
            print("Exiting.")
            sys.exit(0)
    else:
        # WSGI fallback
        port = 8000
        print(f"SSL module or FastAPI not available; running fallback WSGI HTTP server on http://0.0.0.0:{port}")
        httpd = make_server('0.0.0.0', port, wsgi_app)
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            print('\nServer stopped by user')
